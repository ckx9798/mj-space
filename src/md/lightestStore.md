## 🌍 프로젝트 개요

React 애플리케이션의 규모가 커지면서 발생하는 복잡한 상태 관리 문제를 해결하기 위해 Redux, MobX와 같은 라이브러리들이 사용됩니다. 하지만 이러한 도구들을 단순히 사용하는 것을 넘어, 전역 상태 관리의 핵심 동작 원리를 깊이 있게 이해하고 싶었습니다.

또한 자바스크립트 스터디를 통해 클로저, 디자인 패턴과 같은 핵심 개념을 깊이 있게 학습하면서, 이론으로 다져진 지식을 실제 프로젝트에 적용하여 완전히 체화하고 싶다는 동기가 생겼습니다. 이를 위해 불필요한 보일러플레이트 없이 즉시 도입 가능한 중앙화된 상태 저장소를 직접 구현하는 것을 목표로 삼았습니다.

LightestStore는 JavaScript의 근본적인 디자인 패턴에 기반하여, React 환경에 최적화된 경량 상태 관리 라이브러리를 개발하는 프로젝트입니다.

---

## 🎬 프로젝트 주요 기능

### 1️⃣ JavaScript 패턴 기반 아키텍처

- **상태 캡슐화**: JavaScript 클로저를 활용해 외부의 직접적인 상태 수정을 원천 차단하고, 오직 제공된 API를 통해서만 상태에 접근하도록 설계하여 데이터 무결성을 보장합니다.
- **구독(Subscription) 기반 상태 전파**: 옵저버 패턴에 기반한 구독 모델을 통해 상태와 UI를 분리했습니다. 컴포넌트는 스토어의 상태 변경을 '구독'하고, 스토어는 상태가 변경될 때마다 구독 중인 모든 컴포넌트에게 '알림'을 보내는 방식으로 동작하여 예측 가능하고 유지보수하기 쉬운 구조를 완성했습니다.

### 2️⃣ React 최적화 커스텀 훅 `useStore`

- **선언적 API**: `useStore` 훅을 통해 컴포넌트 생명주기에 맞춰 자동으로 상태 변경을 구독하고 해제합니다. 개발자는 복잡한 구독 로직 없이 선언적으로 상태를 사용하기만 하면 됩니다.
- **최적화된 렌더링**: 셀렉터(Selector) 패턴을 도입하여 컴포넌트가 구독하는 특정 상태값이 변경될 때만 리렌더링이 발생하도록 제어합니다. `useCallback`을 함께 활용하여 참조 안정성을 확보하고 불필요한 렌더링 비용을 최소화했습니다.

### 3️⃣ 오픈소스 라이브러리 배포

- **개발자 경험(DX) 최적화**: `package.json`의 `exports`, `types` 필드를 명확히 설정하여 TypeScript 환경에서의 타입 추론과 모듈 해석을 완벽하게 지원합니다.
- **End-to-End 생명주기 관리**: 라이브러리의 초기 기획부터 아키텍처 설계, 핵심 로직 구현, 테스트, 문서화, 그리고 최종 npm 패키지 배포까지 전 과정을 주도적으로 수행했습니다.

---

## 🚀 기술적 도전과 성과

### 🎈 JavaScript 디자인 패턴에 기반한 상태 관리 아키텍처 설계

단순히 라이브러리를 사용하는 것을 넘어, 상태 관리의 핵심을 파고들기 위해 바닐라 JavaScript의 원리를 적극적으로 활용했습니다.

**핵심 설계**

- **클로저(Closure)를 활용한 상태 캡슐화**: 외부에서 직접 접근할 수 없는 비공개 상태(private state)와 구독자 목록(listeners)을 클로저로 구현하여 데이터의 안정성을 확보했습니다.
- **옵저버(Observer) 패턴 직접 구현**: 상태 변경을 외부에 알리는 구독 시스템을 직접 설계했습니다.
  - **`subscribe(listener)` API**: 상태 변경 시 실행될 콜백 함수(listener)를 인자로 받아 내부 구독자 배열에 추가하고, **구독을 해지하는 `unsubscribe` 함수를 반환**합니다. 이는 메모리 누수 방지를 위한 핵심 기능입니다.
  - **`notify()` 로직**: `setState`와 같은 상태 변경 함수가 호출될 때 트리거되며, 내부 구독자 배열을 순회하며 등록된 모든 콜백 함수를 실행시켜 변경된 상태를 전파합니다.

### 🎈 React 최적화를 위한 `useStore` 커스텀 훅 아키텍처 구현

React 환경에서 최상의 성능과 사용성을 제공하기 위해 커스텀 훅의 내부 동작을 세밀하게 설계했습니다.

**핵심 설계**

- **셀렉터(Selector) 기반의 렌더링 최적화**: `useStore` 훅이 반환하는 상태가 아닌, 셀렉터 함수를 통해 반환된 값이 변경될 때만 컴포넌트 리렌더링을 트리거하여 성능을 극대화했습니다.
- **`useCallback`을 통한 참조 안정성 확보**: 셀렉터 함수를 `useCallback`으로 감싸, 불필요한 함수 재생성을 방지하고 React의 렌더링 최적화 메커니즘을 최대한 활용했습니다.

### 🎈 오픈소스 라이브러리 개발 전체 생명주기(Full Lifecycle) 주도

아이디어를 실제 npm 패키지로 완성하는 전 과정을 경험하며 라이브러리 개발 생태계에 대한 깊은 이해를 얻었습니다. 기획, 개발, 문서화, 배포의 각 단계에서 발생할 수 있는 문제들을 예측하고 해결하는 역량을 길렀습니다. 특히 `package.json`의 세부적인 설정을 통해 사용자의 개발 경험을 향상시키는 방법을 터득했습니다.

---

## 🌐 프로젝트 성과 및 학습

### 🎈 상태 관리의 핵심 원리 체득

단순히 상태 관리 라이브러리의 '소비자'에서 벗어나 '생산자'의 관점을 갖게 되었습니다. 클로저, 옵저버 패턴 등 JavaScript의 핵심 원리가 실제 애플리케이션 아키텍처에서 어떻게 작동하는지 체감하며 전역 상태 관리의 내부 동작 방식을 완벽하게 이해할 수 있었습니다.

### 🎈 개발자 경험(DX) 설계의 중요성 인식

라이브러리를 직접 배포하는 과정에서 사용자가 겪을 수 있는 불편함을 미리 고민하고 해결하는 것이 얼마나 중요한지 깨달았습니다. 잘 작성된 문서, 명확한 타입 정의, 직관적인 API 설계가 라이브러리의 기술적 완성도만큼이나 중요하다는 것을 학습했습니다.

### 🎈 선언적 API 설계 역량 강화

`useStore`라는 간단한 커스텀 훅 뒤에 복잡한 구독 관리와 렌더링 최적화 로직을 숨김으로써, '어떻게'가 아닌 '무엇을'에만 집중할 수 있는 선언적 API의 가치를 실현했습니다. 이는 복잡성을 추상화하고 사용성을 높이는 훌륭한 개발 패턴임을 다시 한번 확인하는 계기가 되었습니다.
